
#+TITLE: Ejemplo de Literate Programming: Javascript
#+AUTHOR: Martín Alsinet
#+DATE: 2017
#+OPTIONS: ':t num:nil
#+LANGUAGE: es

* Introducción

En este documento vamos a explorar las técnicas de Literate Programming con un ejemplo práctico en Javascript.

La idea es analizar un archivo de estadísticas de accidentes en la ciudad de Medellín y armar una página sencilla con los resultados más interesantes.

* Setup
** Package.json

Generamos un =package.json= mínimo para comenzar el proyecto

#+BEGIN_SRC js :tangle package.json
{
  "name": "Literate Programming",
  "version": "0.1.0",
  "description": "Literate Programming en Javascript",
  "main": "index.js",
  "scripts": {
    "start": "npm start"
  },
  "author": "Martín Alsinet",
  "license": "CC",
}
#+END_SRC

** Instalar dependencias

Vamos a usar las siguientes dependencias

- sqlite :: Base de datos en un archivo
- csv-parse  :: Parser de archivos CSV

#+BEGIN_SRC sh :results output drawer
npm install sqlite3 csv-parse
#+END_SRC

#+RESULTS:
:RESULTS:

> sqlite3@3.1.13 install /app/node_modules/sqlite3
> node-pre-gyp install --fallback-to-build

[sqlite3] Success: "/app/node_modules/sqlite3/lib/binding/node-v57-linux-x64/node_sqlite3.node" is installed via remote
+ lazy@1.0.11
+ sqlite3@3.1.13
added 111 packages, removed 131 packages and updated 3 packages in 19.627s
:END:

* Fuente de datos
** Origen

La fuente de los datos que vamos a usar es la iniciativa de Open Data de la Alcaldía de Medellín, que pone a disposición [[https://geomedellin-m-medellin.opendata.arcgis.com/datasets/a65c3aff0ef34973a2441b6cd0fbc24a_8][las estadísticas de accidentes de tránsito del año 2016]]

** Formato

El formato de los datos es un archivo CSV, veamos qué tiene adentro

#+BEGIN_SRC sh
ls Accidentalidad_2016.csv
#+END_SRC

#+RESULTS:
: Accidentalidad_2016.csv

** ¿Qué columnas me interesan?

Seleccioné las siguientes columnas para extraer del archivo:

- objectid
- fecha
- hora
- dia
- clase
- gravedad
- barrio
- comuna
- diseño

La fecha y la hora están en dos campos separados, vamos a fusionarlas en uno solo.

Aparentemente hay una ubicación geográfica, porque están los campos =X= e =Y=, pero no son campos de latitud y longitud sino que la ubicación está en formato ARCGIS. Para no complicar el ejemplo, no vamos a utilizar las coordenadas.

* Importar archivo CSV en una base sqlite
** Parsear CSV

   Para parsear el archivo usamos el módulo =csv-parse= que permite leer un archivo y pasarle una función que recibe un array de objetos con un registro por cada fila.

   Entre las opciones disponibles, utilizo el parámetro =columns= para pasarle una función que recibe la primera fila (los encabezados) y debe devolver un array con los nombres de cada columna. Además uso el parámetro =trim: true= para que el módulo csv le quite a los registros automáticamente los espacios en blanco que haya a ambos lados del contenido de cada celda. La otra opción que uso es =ops.to= que permite cortar el procesamiento del archivo luego de un número de líneas.

#+BEGIN_SRC js :results output drawer :tangle parser.js
const fs = require('fs');
const parse = require('csv-parse')


function columns(line)
{
    return line.map(s => s.toLowerCase());
}


parse_csv = function(filename, fn, limit){
    fs.readFile(filename, "utf8", function (err, fileData) {
        var opts = {columns: columns, trim: true};
        if (limit) {
            opts.to = limit;
        }
        parse(fileData, opts, (err, rows) => fn(rows));
    });
}

module.exports = parse_csv;
//parse_csv('Accidentalidad_2016.csv', console.log, 2);
#+END_SRC

#+RESULTS:
:RESULTS:
[ { objectid: '260034',
    x: '833887.52',
    y: '1179103.47',
    radicado: '1520771',
    fecha: '2016-01-29T00:00:00.000Z',
    hora: '06:50 AM',
    dia: 'VIERNES',
    periodo: '2016',
    clase: 'Choque',
    direccion: 'CR 50 CL 8',
    direccion_enc: 'CR  050   008  000 00000',
    cbml: '1507',
    tipo_geocod: 'Malla vial',
    gravedad: 'HERIDO',
    barrio: 'Campo Amor',
    comuna: 'Guayabal',
    diseno: 'Tramo de via' } ]
:END:

** Schema de base de datos

En este caso creo un objeto =schema= que me permite realizar algunas operaciones de mantenimiento de la base de datos. Uso estas operaciones para verificar el funcionamiento del proceso de inserción.

Los métodos del objeto =schema= son:

- create :: Crea la tabla =accidentes= ejecutando la query =schema_q=
- truncate :: Borra todos los registros de la tabla =accidentes=
- rows :: Ejecuta un =SELECT= de la tabla =accidentes= e imprime todos los registros de la tabla con =console.log=
- count :: Ejecuta un =SELECT count(1)= de la tabla =accidentes= e imprime el resutlado con =console.log=

#+BEGIN_SRC js :results output drawer :tangle schema.js
var schema_q = `CREATE TABLE IF NOT EXISTS accidentes (
      id INTEGER PRIMARY_KEY,
   fecha TEXT,
     dia TEXT,
   clase TEXT,
gravedad TEXT,
  barrio TEXT,
  comuna TEXT,
  diseno TEXT
)`


var schema = function(db) {
    return {
        create: function(){
            db.serialize(function() {
                db.run("drop table if exists accidentes");
                db.run(schema_q);
            });
        },
        truncate: function(){
            db.serialize(function() {
                db.run("begin transaction");
                db.run("delete from accidentes");
                db.run("commit");
            });
        },
        rows: function(){
            db.all(
                "select * from accidentes", 
                (err, records) => console.log(records)
            );
        },
        count: function(){
            db.all(
                "select count(1) as rows from accidentes", 
                (err, records) => console.log(records)
            );
        }
    };
};

module.exports = schema;

//const sqlite3 = require('sqlite3').verbose();
//var s = schema(new sqlite3.Database('database.db'));
//s.create();
//s.rows();
//s.count();
#+END_SRC

#+RESULTS:
:RESULTS:
[]
:END:

** Insertar datos

Para insertar los datos parseados uso la función =insert= definida más abajo que ejecuta la query =insert_q= para cada fila del archivo original. Los inserts se ejecutan dentro de una transacción en un entorno serializado, lo que asegura los datos se inserten en secuencia. Luego del commit de la tranasacción se llama a una función =finished= que indica que se ha terminado de procesar los datos.

Antes de insertar cada registro uso la función =fix_date= que fusiona los dos campos =fecha= y =hora= en un solo campo fecha con toda la información. Además le cambia el formato a la hora, dado que en el archivo original se encuentra en formato AM/PM y eso complica las consultas.

Las funciones show_X las uso solamente para poder mostrar cómo se van modificando los datos, desde el parseo original, pasando por las correcciones de la fecha y luego la query resultante que se va a ejecutar.

#+BEGIN_SRC js :results output drawer
var insert_q = `INSERT INTO accidentes (
  id, fecha, dia, clase, gravedad, 
  barrio, comuna, diseno
) VALUES (
  :objectid, ':fecha', ':dia', ':clase', ':gravedad', 
  ':barrio', ':comuna', ':diseno'
)
`;


function query(q, val) {
    return q
        .replace(':objectid', val.objectid)
        .replace(':fecha', val.fecha)
        .replace(':dia', val.dia)
        .replace(':clase', val.clase)
        .replace(':gravedad', val.gravedad)
        .replace(':barrio', val.barrio)
        .replace(':comuna', val.comuna)
        .replace(':diseno', val.diseno)
}


function ampm_to_24h(text)
{
    var hour = parseInt(text.substr(0,2));
    var ampm = text.substr(6,2);
    if ((hour == 12) && (ampm == "AM")) {
        hour = 0;
    }
    if ((hour != 12) && (ampm == "PM")) {
        hour+= 12;
    }
    return ("0"+String(hour)).substr(-2)+":"+text.substr(3,2);
}


function fix_date(row)
{
    row.fecha = row.fecha.substr(0,10) + " " + ampm_to_24h(row.hora);
    return row;
}


function show_r(rows)
{
    rows.map(function(row){
        console.log(row);
        console.log("");
    });
}


function show_f(rows)
{
    rows.map(function(row){
        console.log(fix_date(row));
        console.log("");
    });
}


function show_q(rows)
{
    rows.map(function(row){
        console.log(query(insert_q, fix_date(row)));
    });
}


function show(rows)
{
    rows.map(function(row){
        console.log(row);
        console.log("");
        console.log(query(insert_q, row));
        console.log(query(insert_q, fix_date(row)));
    });
}


function finished()
{
    if (schema !== null) {
        schema.count();
        //schema.rows();
    }
}


function insert(rows)
{
    db.serialize(function() {
        db.run("begin transaction");
        rows.map(function(row){
            db.run(query(insert_q, fix_date(row)));
        });
        db.run("commit");
        finished();
    });
}


const sqlite3 = require('sqlite3').verbose();
const parser = require("/app/parser.js");
const db_schema = require("/app/schema.js");
const inputFile = 'Accidentalidad_2016.csv';
var db = new sqlite3.Database('database.db');


//parse_csv(inputFile, show_r, 2);
//parse_csv(inputFile, show_f, 2);
//parse_csv(inputFile, show_q, 2);
//parse_csv(inputFile, show, 2);


schema = db_schema(db);
schema.truncate();
//parse_csv(inputFile, insert, 5);
//parse_csv(inputFile, insert);
#+END_SRC

#+RESULTS:
:RESULTS:
[ { rows: 42841 } ]
:END:

* Explorar las queries más interesantes

Me gustaría obtener la siguiente información:

- Cantidad de accidentes por mes
- Cantidad de accidentes por día de la semana
- Cantidad de accidentes por hora del día
- Cantidad de accidentes por gravedad
- Cantidad de accidentes por comuna y barrio
- Cantidad de accidentes por lugar

** Queries

En esta sección creo el objeto =query= que almacena cada una de las consultas que voy a utilizar. Además le agregué un método =rows= que devuelve un select de la tabla para cuando quiera revisar los registros individualmente.

#+BEGIN_SRC js :results output raw drawer :tangle queries.js
function table_row(cells){
    console.log("|" + cells.join("|") + "|");
}


function table(rows){
    console.log("|---|");
    table_row(Object.keys(rows[0]));
    console.log("|---|");
    rows.map(row => table_row(Object.keys(row).map(k => row[k])));
    console.log("|---|");
}


var query = {

    rows: (limit) => {
        return "SELECT * FROM accidentes LIMIT " + limit.toString()
    },

    por_mes: 
    ` SELECT substr(fecha, 0, 8) AS mes, count(1) AS accidentes 
    FROM accidentes 
GROUP BY substr(fecha, 0, 8)
ORDER BY 1 DESC`,

    por_dia: 
    ` SELECT dia, count(1) AS accidentes 
    FROM accidentes 
GROUP BY dia
ORDER BY 2 DESC`,

    por_hora: 
    ` SELECT substr(fecha, 12, 2) as hora, count(1) AS accidentes 
    FROM accidentes 
GROUP BY substr(fecha, 12, 2)
ORDER BY 1`,

    por_gravedad: 
    ` SELECT gravedad, count(1) AS accidentes 
    FROM accidentes 
GROUP BY gravedad
ORDER BY 2 DESC`,

    por_comuna: 
    ` SELECT comuna, count(1) AS accidentes 
    FROM accidentes 
GROUP BY comuna
ORDER BY 2 DESC`,

    por_barrio: 
    ` SELECT barrio, count(1) AS accidentes 
    FROM accidentes 
GROUP BY barrio
ORDER BY 2 DESC`,

    por_comuna_y_barrio: 
    ` SELECT comuna, barrio, count(1) AS accidentes 
    FROM accidentes 
GROUP BY comuna, comuna, barrio
ORDER BY 3 DESC`,

    por_diseno:
    ` SELECT diseno, count(1) AS accidentes 
    FROM accidentes 
GROUP BY diseno
ORDER BY 2 DESC`

};

module.exports = {
    query: query,
    table: table
};

// const sqlite3 = require('sqlite3').verbose();
// var db = new sqlite3.Database('database.db');
// db.all(
//     query.por_dia, 
//     //(err, rows) => console.log(rows)
//     (err, rows) => table(rows)
// );

#+END_SRC

#+RESULTS:

** Accidentes

En esta sección, usando el objeto =query=, creo un objeto =accidentes= que es el que se encarga de realizar efectivamente las consultas sobre la base de datos. Debido a que es un ejercicio de ejemplo no le agregué ningún tipo de control de errores. Si la query falla por algún motivo node va a devolver el error en la consola.

#+BEGIN_SRC js :results output raw drawer :tangle accidentes.js
var accidentes = function(db, query){
    return {
        rows: function(limit, fn){
            db.all(
                query.rows(limit), 
                (err, rows) => fn(rows)
            );
        },
        por_mes: function(fn){
            db.all(
                query.por_mes, 
                (err, rows) => fn(rows)
            );
        },
        por_dia: function(fn){
            db.all(
                query.por_dia, 
                (err, rows) => fn(rows)
            );
        },
        por_hora: function(fn){
            db.all(
                query.por_hora, 
                (err, rows) => fn(rows)
            );
        },
        por_gravedad: function(fn){
            db.all(
                query.por_gravedad, 
                (err, rows) => fn(rows)
            );
        },
        por_barrio: function(fn){
            db.all(
                query.por_barrio, 
                (err, rows) => fn(rows)
            );
        },
        por_comuna: function(fn){
            db.all(
                query.por_comuna, 
                (err, rows) => fn(rows)
            );
        },
        por_comuna_y_barrio: function(fn){
            db.all(
                query.por_comuna_y_barrio, 
                (err, rows) => fn(rows)
            );
        },
        por_diseno: function(fn){
            db.all(
                query.por_diseno, 
                (err, rows) => fn(rows)
            );
        },
    };
}

const q = require('/app/queries.js');
const sqlite3 = require('sqlite3').verbose();
var db = new sqlite3.Database('database.db');

var acc = accidentes(db, q.query);

module.exports = acc;

//acc.por_dia(console.log);
acc.rows(1, console.log);
#+END_SRC

#+RESULTS:
:RESULTS:
[ { id: 260034,
    fecha: '2016-01-29 06:50',
    dia: 'VIERNES',
    clase: 'Choque',
    gravedad: 'HERIDO',
    barrio: 'Campo Amor',
    comuna: 'Guayabal',
    diseno: 'Tramo de via' } ]
:END:

* Crear una API JSON
** API

Para crear la API me baso en el objeto accidentes del punto anterior.

#+BEGIN_SRC js :results output raw drawer :tangle api.js
var accidentes = require("/app/accidentes.js");
var view_as_table = require("/app/queries.js").table;

accidentes.por_dia(view_as_table);

#+END_SRC

#+RESULTS:
:RESULTS:
|-----------+------------|
| dia       | accidentes |
|-----------+------------|
| VIERNES   |       6916 |
| MARTES    |       6557 |
| JUEVES    |       6546 |
| MIÉRCOLES |       6453 |
| SÁBADO    |       6274 |
| LUNES     |       6109 |
| DOMINGO   |       3986 |
|-----------+------------|
:END:

* Hacer una página mínima con resultados
** Rutas estáticas
** Index HTML
** Accidentes por comuna y barrio
* Putting it all together
